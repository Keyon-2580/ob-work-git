1. 软件退化和As（）的变化关系，积累的技术债务怎么评价
2. 依赖关系的变化，定义不同的拓扑结构，过程中怎么标记退化。
	1. 比如从简单的两个类逐渐到多个类复杂的变化

1. 架构异味的演化
	1. 循环依赖
	2. 集线器依赖
	3. 不稳定依赖
2. 背景
	1. 架构异味检测
	2. 迭代分析
	3. 架构异味对其影响

Q：
1. 怎么定义技术债务（架构）
2. 架构异味的定义按照已有研究？
3. 对架构异味再加新的？
	1. CD
	2. HD
	3. UD
	4. ？
4. 绑定在开发人员身上
5. 找突变的commit？
6. 到底算不算架构异味
7. pagerank ，通过最核心的类去评估影响，同时绑定人


几个指标
1. 由依赖导致的架构异味
2. 架构异味在迭代中的变化，以及评价指标/或者技术债务（共同修改）
3. 这个变化导致的评价指标变化绑定在开发者身上，
4. 以及在迭代周期中什么时候出现异味较多，快速迭代orFixbug
5. 一个是评分的变化一个是突增的架构异味


## 矩阵分析
- 构建矩阵，一个大的修改版本认为是一次架构设计，或者一个功能点的分析（一个新的feature）
- 横轴是当前开发者后续基于这次feature对架构的调整（PDG）
- 纵轴是其他开发者对这次feature的架构调整

分析：
1. 该开发者自己在架构上做调整，是否引入了AS
2. 其他开发者在架构上调整是否引入AS
3. 其他开发者的调整是否被沿用或者废弃
4. 
## 关注的设计贡献指标


- 涉及到抽象类、接口之间的关系（高层），一次设计
变化情况，和时间*关联做损失*

循环依赖：找到单向性比较明显的，对引入循环的那一个做减分。
- 中心性算法，拿到关键类找到第一次引入的情况，之后迭代研究变换
- AS逆向追溯，但是是阈值评估，通过变化得到每人每次对阈值的变化影响。
- 高层设计，接口或者抽象类的增加依赖，
	- 子类如果有冲突或者重复的认为是负面的
	- 普通的不管
	- 有高层设计的认为是架构依赖设计

## 正向追溯
- 引入架构级别的依赖设计的时候记录下来，如果一个子类继承了父累，子类新增依赖的时候检查 是否和父类冲突。
- 对于当前版本出现的AS情况进行向后追溯，每次检查是否有新的变化或者。
	

- 中心性文件：从当前版本检查出中心性文件之后从文件的引入去看该文件的依赖变化（暂时先不考虑）


## 逆向追溯
- 对于出现的AS进行逆向追溯，追溯每一个对该文件修改的人的行为造成什么影响，构建一个变化图
	- 对HL这种可能方便构建一个全阶段的变更图
	- 对于CD，可以先考虑两个文件的循环依赖
	- 对于UD，研究阈值的设置，只去追溯到引入的人
- 
## 变更记录
[[2023-12-18#表结构]]


## 架构级别的依赖设计
- 引入的时候识别是架构层面
	1. 两个抽象类直接的依赖关系
	2. 抽象类依赖于另一个新的包中文件？
	3. 抽象类和接口的依赖关系
- 对于架构级别的依赖关系消除的时候去记录存活时间，作为架构设计的评价指标之一，根据时间长度做损失函数（eg.log）计算得到设计贡献的指标。
- 对于子类出现依赖变更
	1. 识别父类是否已经有相关的依赖，依赖的是另一个抽象类还是其子类
	2

